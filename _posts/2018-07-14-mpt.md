---
layout: post
title: 默克尔·帕特里夏树
category: algorithm
date: 2018-07-14
---

默克尔·帕特里夏树(Merkle Patricia Tree 或简称 MPT)，提供了一个基于加密学的，自校验防篡改的数据结构，用来存储键值对关系。
尽管在多数规范范围内，限定键值的类型只能是字符串(但仍对所有的类型适用，只需提供一个简单的序列化机制将要存储的类型与字符串进行转换即可)。
修改后的 MPT 是确定的，也就是说具有相同键值绑定的 MPT 保证了直到最后一个字节都完全一样并且具有相同的 **roothash**。

Merkle Patricia Trie，顾名思义，即符合 **PATRICIA** 性质的 Merkle Tree。

> PATRICIA: **P**ractical **A**lgorithm **T**o **R**etrieve **I**nformation **C**oded **I**n **A**lphanumeric.

默克尔·帕特里夏树随着区块链项目的发展而得到了普及，那么使用这种数据结构的好处又是什么？

<br />

---

<br />

## Patricia Trie

Patricia Trie 在字符串子串匹配上有着非常优异的表现，这使得它经常成为一种高效的全文检索算法，在自然语言处理领域也有广泛的应用。
不少人认为 Patricia Trie 与基数树(Radix Trie)是同一种数据结构，实际上 Patricia Trie 是一种二叉树，其本质上是一棵 **基数为 2** 的基数树。

> 这里的基数是指 **radix** 或者底数 **base**，而非集合中所描述的基数(Cardinal number)。

Patricia Trie 的每个节点都有且仅有两个分支，为了对一个键任意位置的位单独进行比较，每个节点都拥有一个位索引值。
这个值指定一个键(字符串)中一个位的位置，这个索引值通常都是多个键的相同位中第一个产生差异的地方。

举个例子，假如有以下的键组成的集合：

<pre><code>smile:   0111 0011  0110 1101  0110 1001  0110 1100  0110 <b>0</b>101  0<b>0</b>00 0000  0000 0000
smiled:  0111 0011  0110 1101  0110 1001  0110 1100  0110 <b>0</b>101  0<b>1</b>1<b>0</b> 0100  0000 0000
smiles:  0111 0011  0110 1101  0110 1001  0110 1100  0110 <b>0</b>101  0<b>1</b>1<b>1</b> 0011  0000 0000
smiling: 0111 0011  0110 1101  0110 1001  0110 1100  0110 <b>1</b>001  0110 1110  0110 0111</code></pre>

产生差异的位均已加粗标明，这个位置将成为一个二分叉的节点，节点的位索引值即该位的下标(按照从左到右即人类阅读，也是字符串解析成 ASCII 的顺序)。

这些键所组成的 Patricia Trie 看起来会是这样的：

![PAT Trie 1][pat1]

Patricia Trie 随着新键的插入，树的深度也随之增加；而随着新键的长度越来越长，生成节点的位索引值也会变得越来越大(父级的位索引总是低于其子级)。
如果直接用单个字符作为存储结点，比如传统的基数树，势必构造出一棵多叉树，检索起来将会相当不便(如果是中文字符的话就完蛋了)。

Patricia Trie 查找的时间复杂度和树的深度有关，由于树的构造取决于不同位上 0 、1 的分布，因此又点像二叉查找树。
最坏情况下是单支树，此时的时间复杂度是 **O(n)**，n 为字符串的长度。最好情况下是平衡二叉树，时间复杂度是 **O(log₂(n))**。
另外，作为压缩的二叉查找树，其存储的空间代价也大大减少了。

> 一些更复杂的 PATRICIA 算法甚至能够包含可变长的键，具体这里不再讨论。

<br />

---

<br />

## Merkle Tree

Merkle Tree，中文叫梅克尔树，也叫默克尔树，为了方便与简洁，以下简称 MT。

MT 的应用领域相当广泛，本身需要对数据进行完整性效验的领域就不少，但主要还是在于它高效完成效验工作的同时还能精确定位到那些损坏的数据。
**如果要我用一句话来概括 MT 的存在意义，那就是数据的完整效验。**

### Hash

MT 通常也被称作 Hash Tree(哈希树)，顾名思义，就是存储 hash 值的树。

对数据进行相等性判断不管在什么时候都是一件非常频繁的事情，使用 hash 代替数据本身进行比较已经是一件众所周知且默认的规矩。
事实上，有些操作系统或者程序语言在生成一份数据的同时就已经为它做过 hash 运算，并且在一个地方把这个 hash 值存起来用于将来进行比较。
举个例子，Java 中所有的对象都会继承两个来自 Object 类的方法：`hashCode()` `equals(obj)`。

但 hash 并不是万能的，如果要比较对象的是两个数据量庞大的多维数组时，比如两个文件夹，如果要找出所有不同的数据呢？
又或者对下载完成的文件的 hash 进行验证，发现文件损坏时，如何知道损坏的是具体哪一部分？对于后者，就只能整个文件重新下载。

### 特征 & 结构

MT 大多数是二叉树，也可以多叉树。

#### 非叶子节点的 hash 值是根据它下面所有的子节点值通过相同的 hash 算法计算得出：

![Merkle Tree 1][mt-node]

**chf** 是加密哈希函数，通常被设计为不可逆的，这里列举一些比较知名的 chf：

- MD5：发表于 1992 年。
- SHA2：发表于 2001 年，比特币的完整性，区块链接和 hashcash 成本函数均使用 SHA2-256 作为加密函数。
- KECCAK：2012 年 10 月，Keccak 被选为 NIST 散列函数竞赛的胜利者。
- SHA3：即 KECCAK(换了个名字)，2014 年 NIST 发布了 FIPS 202 的草案，2015 年 8 月，SHA-3 由 NIST 通过 FIPS 202 正式发表。
- CRC：发表于 1961 年，如果数据不会受到蓄意的损坏或篡改，可以改用一些安全性低但效率高的校验和算法，比如 CRC。


#### 叶子节点的值是数据集合或者单元数据的 hash 值：

![Merkle Tree 2][mt-leaf]

### 检索数据块

为了方便理解，我举一个例子：

我们在使用一些带 VCS(版本控制系统) 的代码管理工具时(Git, SVN, etc.)，即便项目十分庞大，当修改完一个本地文件后，
VCS 总能非常迅速地找到当前版本下所有的改动过的文件，甚至能准确定位到具体某一行被修改的内容，现在就来模拟一下这种情况。

假设项目仓库有 8 个数据文件分别是 File0-7，生成 MT 的 chf 是纯函数，当使用文件名顺序计算文件 hash 值时，这棵 MT 看起来会是这个样子的：

![Merkle Tree 2][mt-cmp1]

然后我修改了其中的 File2：

![Merkle Tree 2][mt-cmp2]

那么接下来就简单了，从 roothash 开始，逐一检查节点的 hash 值，直到找到某个叶子为止。
每个节点只需要判断一次，因为至少有一处不同，如果当前节点 hash 没有变化，那么就已经可以确定是另一个了。
也许这个例子看不太出 MT 拥有的优势，而且多数情况下会不止一个不相同的数据，但当整体的数据量变多以后，搜索的次数会以指数级降低。

想要检查出某个文件具体被修改的位置也只需要如法炮制。

比如文本文件，只需将每个段落当作一个数据块，然后就可以用所有段落去构建出一棵 MT 树。想检查具体的某一段落，可以用标点符号或空格等...
而对于同样的数据，树的节点越密集，越能够突出具体的细节。

当然，VCS 并不是如此轻松就能实现的廉价物。有的 VCS 在将文本数据转变成 MT 前会先对其进行 parsing，但一种 parsing 只能针对一种特定的数据。
经过 parsing 数据会变成一棵 **AST**，而 MT 的叶子便是一棵棵 AST 的 hash 值。

比如两段程序语言文本数据 `c = a + b` 与 `c=a+b` 会生成两串毫无关联的 hash 值，但是能解析出相同的 AST；
像 `f() { c = 3 + a }` 和 `f() { c = 1 + 2 + a }` 有些 parser 也能够解析出同样的 AST。

> parsing：当一项数据能够被转变成某种特定的数据结构时，通常便意味着这项数据是可编程的。而将数据转变为数据结构的过程便可以称之为 parsing。

#### Merkle DAG

说到 VCS，就不得不提一下 Git 使用的一种叫 **Merkle DAG** 的数据结构，DAG 也被实际应用到了 IPFS 以及区块链中。
关于 DAG，可以简单地把 Git 仓库中那棵(由 branch 和 commit 构成的)树想象成 DAG 的数据结构。

![Merkle Tree 2][DAG]

> AST：Abstract Syntax Tree，抽象语法树。
> <br />
> DAG：Directed Acyclic Graph，有向无环图。
> <br />
> IPFS：InterPlanetary File System，星际文件系统

#### IPFS

IPFS 是一种在 P2P 的环境中进行寻址的互联网传输方案，同时也是一种内容可寻址的对等超媒体分发协议。
其概念大致可以概括为**内容可寻址，版本化，点对点超媒体的分布式存储，传输**。

如果说基于 HTTP 的网络协议是通过域名建立起 C/S 模型后，对数据的路径通过**请求、应答**的方式进行传输的话；
那么 IPFS 就相当于大家共处一个 P2P 的网络集群环境中，通过数据唯一的 hash 值在 Merkle DAG 中进行索引，
在随机分布的节点群中随机地获取数据包，并最终才拼凑成一个完整的数据。

### 不足之处

通过上面的例子，可以对 MT 部分操作的复杂度进行整理：

- 创建一棵 MT 的时间复杂度为 **O(2n)**，这里指 chf 的执行次数。
- 假设这棵 MT 被设计为平衡二叉树，则生成 MT 的空间复杂度为 **O(log₂(n))**，这里指树的高度。
- 同上，找到第一个不相同的元素的时间复杂度为 **O(log₂(n))**，这里指比较的次数。
- 单纯比较两组数据是否相同则只是 **O(1)**。

#### 更新

对于 MT 而言，叶子 hash 的更新也就意味着与该叶子节点相关的所有父节点的 hash 值都需要得到更新：

![Merkle Tree 2][mt-up]

> 蓝色表示需要 re-hashing 的节点。

更新并不会对 MT 的结构造成影响，在更新完叶子的 hash 后返回树根路径时沿路更新各节点的 hash 即可，时间复杂度为 **O(log₂(n))**。

#### 插入 & 删除

插入和删除则肯定会改变 MT 树的结构，假如我在原来的树上插入一个排序靠前的新块 data0：

![Merkle Tree 2][mt-ins1]

> 蓝色表示需要 re-hashing 的节点。

但考虑需要满足以下条件：

- 新树在更新叶子数据时 re-hashing 操作的次数控制在 **log₂(n)** 以内；
- 新树对数据块的校验次数在 **log₂(n)** 以内；
- 除非原始树的 n 是偶数，插入数据后的树没有孤块；如果有，那么孤块是最后一个数据块；
- 数据块的顺序保持一致； 
- 插入后的 MT 保持平衡。

所以新 MT 的结构应该要这样的：

![Merkle Tree 2][mt-ins2]

> 蓝色表示需要 re-hashing 的节点。

相比第一种插入方式，第二种插入方式使新的 MT 保持了良好的平衡性，但是几乎重算了整棵 MT 的所有 hash。
所以对于 MT 的插入和删除操作实际是一个工程上的问题，对于不同问题可能会有不同的实现方式。

<br />

---

<br />

## Merkle Patricia Tree

以太坊中也有使用到 Merkle Tree，但以太坊使用的 MT 是经过修改的，也就是一开始讲到的 Merkle Patricia Tree。

站在区块链的角度来看，一笔交易被执行以后就已经是不可逆的。
这也就意味着对于区块链而言，储存着交易的树一旦生成，对于树的修改、插入与删除都是无意义的，最重要且最有意义的操作是数据的**效验**。
而用作储存交易信息的数据结构， Merkle Tree 无疑是最合适的选择。

虽然所有的交易和收据都能采用 MT 作为数据结构，但以太坊的区块中不止储存着交易，还有状态(state)。
状态树中储存的数据并非不可逆的，树的叶子是一个 20 字节的地址，该值映射了一个叫作 Account 的对象。
状态树需要频繁地进行写操作：balance 和 nonce 经常需要更新；叶子也会经常插入以及删除。

来看一个例子，假设我们把状态树抽象成这样一种结构(不考虑其中的映射与加密)：

![Merkle Tree 2][state-trie]

两个区块的状态树之间存在的唯一区别就是：Account100 这个对象的某个数据从 30 变成了 100，其余部分完全一致。

那么就需要这样一种数据结构，它能在一次插入、更新、删除操作后快速计算到树根，而不需要重新计算整棵树的 hash。
这种数据结构同样得包括两个非常好的第二特征：

- 树的深度是有限制的，不然，攻击者可以通过操纵树的深度，或者执行拒绝服务攻击(DOS attack)，使得区块更新变得极其缓慢。
- roothash 只取决于数据，和其中的更新顺序无关。换个顺序进行更新，甚至重新从头计算树，并不会改变根。

一般的 MT 不考虑顺序的话不同状态下生成的树的形状甚至都会完全不同，而 Trie 是最接近同时满足上面的性质的的数据结构。
同时，为了得到的树能够更高效的进行工作，MPT 便是最佳的数据结构。

经过修改的 MPT 存在着 4 种功能各异的节点，4 种节点的值也采用了不同的数据结构：

- null：表示空字符串。
- branch：一个长度为 17 的数组 [ v0 ... v15, vt ]，也被称为**分支**节点。
- leaf：一个长度为 2 的数组 [ encodedPath, value ]。
- extension：一个长度为 2 的数组 [ encodedPath, key ]，与 leaf 不同的是 key 是一个键，用于在数据库中寻值或者通过映射获取更复杂的数据。

<!--
mark TODO
1 纂改 root-hash：交易或节点验证
2 工作量作弊：
-->

### 以太坊中的 MPT

以太坊中所有用到的 Trie 都采用了 Merkle Patricia Tree 的数据结构。

这里介绍几个以太坊中被频繁使用到的 Trie：

- StorageTrie：账户数据的储存树，每个账户都有一个单独的储存树。
- StateTrie：该树储存了所有账户的所有数据，树的叶子是一个 20 字节地址，该地址映射了一个叫 Account 的对象。
- TransactionsTrie：区块中列出的所有交易的交易树。
- ReceiptsTrie：区块中列出的所有交易收据的收据树。

而它们的 roothash 分别有不同的功能：

- storageRoot：默认是空值(0x`64个0`)，该值代表了某个 Account 的储存数据。
- stateRoot：该值代表了整个以太坊的当前状态。
- transactionsRoot：代表了某区块中列出的所有交易的加密结果。
- receiptsRoot：代表了某区块中列出的所有交易收据的加密结果。

{% assign img_url = "/images/mpt" %}

[pat1]: {{img_url}}/pat1.png
[mt-node]: {{img_url}}/mt-node.png
[mt-leaf]: {{img_url}}/mt-leaf.png
[mt-cmp1]: {{img_url}}/mt-cmp1.png
[mt-cmp2]: {{img_url}}/mt-cmp2.png
[DAG]: {{img_url}}/DAG.png
[mt-up]: {{img_url}}/mt-up.png
[mt-ins1]: {{img_url}}/mt-ins1.png
[mt-ins2]: {{img_url}}/mt-ins2.png
[state-trie]: {{img_url}}/state-trie.png

[trie]: https://zh.wikipedia.org/wiki/Trie
[radix trie]: https://en.wikipedia.org/wiki/Radix_tree
[merkle tree]: https://en.wikipedia.org/wiki/Merkle_tree
[merkle write]: https://crypto.stackexchange.com/questions/22669/merkle-hash-tree-updates
