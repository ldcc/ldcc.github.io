---
layout: post
title: 默克尔·帕特里夏树
category: ALGO
date: 2018-07-14
---

默克尔·帕特里夏树(Merkle Patricia Tree 或简称 MPT)，提供了一个基于加密学的，自校验防篡改的数据结构，用来存储键值对关系。
尽管在多数规范范围内，限定键值的类型只能是字符串(但仍对所有的类型适用，只需提供一个简单的序列化机制单射到相应的字符串数据即可)。
修改后的 MPT 是确定的，即具有相同键值绑定的 MPT 保证了直到最后一个字节都完全一样并且具有相同的 roothash。

Merkle Patricia Trie，顾名思义，即符合 PATRICIA 性质的 Merkle Tree。

> PATRICIA: **P**ractical **A**lgorithm **T**o **R**etrieve **I**nformation **C**oded **I**n **A**lphanumeric.

默克尔·帕特里夏树随着区块链项目的发展而被大众所熟知，那么使用这种数据结构的好处又是什么？

{% include brline %}

## Patricia Trie

Patricia Trie 在字符串子串匹配上有着非常优异的表现，这使得它一度成为一种高效的全文检索算法，在自然语言处理领域也有广泛的应用。
不少人认为 Patricia Trie 与 Radix Tire(基数树) 是同一种数据结构，实际上 Patricia Trie 是一棵二叉树，其本质上是一棵基数为 2 的基数树。

Patricia Trie 的每个节点都有且仅有两个分支，为了对一个键任意位置的位单独进行比较，每个节点都拥有一个位索引值。
这个值指定一个键(字符串)中一个位的位置，这个索引值通常都是多个键的相同位中第一个产生差异的地方。

举个例子，假如有以下的键组成的集合：

<pre><code>smile:   0111 0011  0110 1101  0110 1001  0110 1100  0110 <b>0</b>101  0<b>0</b>00 0000  0000 0000
smiled:  0111 0011  0110 1101  0110 1001  0110 1100  0110 <b>0</b>101  0<b>1</b>1<b>0</b> 0100  0000 0000
smiles:  0111 0011  0110 1101  0110 1001  0110 1100  0110 <b>0</b>101  0<b>1</b>1<b>1</b> 0011  0000 0000
smiling: 0111 0011  0110 1101  0110 1001  0110 1100  0110 <b>1</b>001  0110 1110  0110 0111</code></pre>

产生差异的位均已加粗标明，这个位置将成为一个二分叉的节点，节点的位索引值即该位的下标(按照从左到右人类阅读的顺序)。

这些键所组成的 Patricia Trie 看起来会是这样的：

![PAT Trie][pat-trie]

随着新节点的插入，Patricia Trie 的深度也随之增加；而随着节点长度的增加，生成节点的位索引值也会变得越来越大(父节点的位索引总是低于其子节点)。
如果直接用单个字符作为存储结点，比如传统的基数树，势必构造出一棵多叉树，检索起来将会相当不便(如果是中文字符的话就完蛋)。

Patricia Trie 查找的时间复杂度和树的深度有关，由于树的构造取决于不同位上 0, 1 的分布，因此又点像二叉查找树。
最坏情况下是单支树，此时的时间复杂度是 __O(n)__，n 为字符串的长度。最好情况下是平衡二叉树，时间复杂度是 __O(log(n))__。
另外，作为压缩的二叉查找树，其存储的空间代价也大大减少了。

> 一些更复杂的 PATRICIA 算法甚至能够包含可变长的键，具体这里不再讨论。

{% include brline %}

## Merkle Tree

Merkle Tree，中文叫梅克尔树，也有人叫默克尔树，为了防止混淆，这里我统一称呼它 Merkle Tree。

Merkle Tree 的应用领域相当广泛，本身需要对数据进行完整性效验的领域就不少，但主要还是在于它高效完成效验工作的同时还能精确定位到那些损坏的数据。

### Hash

Merkle Tree 通常也被称作 Hash Tree(哈希树)，顾名思义，就是存储 hash 值的树。

对数据进行等价关系的判断是一项非常频繁的操作，对于较大的数据而言，使用 hash 值代替数据进行比较是一种比较可靠的手段。
举个例子，Java 中的对象都会继承两个来自 Object 类的方法：`hashCode()`, `equals(obj)`。

这里列举一些较为知名的加密哈希函数：

- CRC(Cyclic redundancy check)：发布于 1961 年，由于易于二进制的计算机硬件使用、容易进行数学分析并且尤其善于检测传输通道干扰引起的错误。
  如果确定数据不会受到蓄意的损坏或篡改，可以改用一些安全性低但效率高的校验和算法，比如 CRC。
- MD5(Message Digest Algorithm5)：发布于 1992 年，曾经被广泛使用的一种加密函数，用以提供消息的完整性保护。
  2004年，MD5 被证实算法无法防止碰撞(collision)，因此已不适用于安全性认证。
- SHA(Secure Hash Algorithm)：SHA 系列算法由美国国家安全局(NSA)设计，并由美国国家标准与技术研究院(NIST)发布为联邦数据处理(FIPS)标准。
  - SHA-0：于 1993 年发布，当时被称做安全散列标准(Secure Hash Standard)，发布之后很快就被 NSA 撤回，是 SHA-1 的前身。
  - SHA-1：于 1995 年发布，SHA-1 在许多安全协议中广为使用，包括 TLS, SSL, PGP, SSH, S/MIME 及 IPsec ，曾被视为是 MD5 的后继者。
    但 SHA-1 的安全性已经不被大多数的加密场景所接受。2017 年荷兰密码学研究小组 CWI 和 Google 正式宣布攻破了 SHA-1。
  - SHA-2：于 2001 年发布，包括 SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256。
  - Keccak：2012 年 10 月，Keccak 被选为 NIST 散列函数竞赛的胜利者。
  - SHA-3：SHA-3 原名就是 Keccak，2014 年 NIST 发布了 FIPS 202 的草案，2015 年 8 月，SHA-3 由 NIST 通过 FIPS 202 正式发表。

> 以上内容摘选自维基百科。

hash 算法只能帮助我们快速进行比较，当要比较对象的是两组数据量庞大的多维数组时，比如两个文件夹，如何快速找出所有不同的数据呢？
又或者对下载完成的文件进行完整性验证，发现文件损坏时，如何知道损坏的是具体哪一部分？这时，只能整个文件重新下载。

### 特征 & 结构

Merkle Tree 大多数是二叉树，也可以多叉树。

非叶子节点的 hash 值根据所有子节点的 hash 值通过相同的算法计算得出：

![Merkle Tree 1][mt-node]

叶子节点的 hash 值是某份数据的 hash 值：

![Merkle Tree 2][mt-leaf]

### 检索数据块

为了方便理解，我举一个例子：

我们在使用一些带 VCS(版本控制系统) 的代码管理工具时(Git, SVN ...)，即使项目十分庞大，在修改完一个本地文件后，
VCS 总能非常迅速索引到修改前后的数据及路径，还能准确定位到具体某一行被修改的内容，现在就来模拟一下这种情况。

假设仓库有 8 份文件 File0-7，加密函数是 chf，那么这棵 Merkle Tree 看起来会是这个样子的：

![Merkle Tree 2][mt-cmp1]

然后我修改了其中的 File2：

![Merkle Tree 2][mt-cmp2]

然后就可以从 roothash 开始，逐一检查节点的 hash 值，直到找到某个叶子为止。

对于其他类型的数据可以如法炮制：

- 对于文本文件，可以将一个段落当作叶子。
- 对于段落，可以用标点符号或空格等。
- 对于一些可编程的代码文件而言，可以先 parsing 成一棵 AST，比如两段表达式 `f(a) { c = 3 + a }` 和 `f(a) { b = 1 + 2; c = b + a }`，
  作为没有意义的文本数据时会生成两串毫无关联的 hash 值，但可以优化成两棵相同的 AST。

树的节点越密集，越能够突出具体的细节。

> 当一段文本能够被转变成某种特定的数据结构时，通常便意味着这段文本是可编程的。而转换的过程可以称之为 parsing。
> 
> 这里只是举个例子，实际中的 VCS 要做的事情远比这里复杂。

说到 VCS，就不得不提一下 Git 使用的一种叫 Merkle DAG 的数据结构，Merkle DAG 也被实际应用到了 IPFS(InterPlanetary File System) 以及区块链应用中。

![Merkle Tree 2][DAG]

IPFS 是一种支持在 P2P 环境中进行寻址的互联网传输方案，同时也是一种内容可寻址的对等超媒体分发协议。
其概念大致可以概括为内容可寻址，版本化，点对点超媒体的分布式存储，传输。

如果说基于 HTTP 的网络协议是通过域名建立起 C/S 模型后，通过路径使用请求、应答的方式进行传输的话；
那么 IPFS 就相当于大家共处一个 P2P 的网络集群环境中，通过数据唯一的 hash 值在 Merkle DAG 中进行索引，
在随机分布的节点群中随机地获取数据包，并最终才拼凑成一个完整的数据。

### 不足之处

话题扯远了，通过上面的例子，可以对 Merkle Tree 部分操作的复杂度进行整理：

- 创建一棵 Merkle Tree 的时间复杂度为 __O(n)__，这里指 chf 的执行次数。
- 生成的 Merkle Tree 的空间复杂度为 __O(log(n))__，这里指树的高度。
- 查找元素的时间复杂度为 __O(log(n))__，这里指比较的次数。
- 单纯判断两组数据（roothash）的等价关系则只需 __O(1)__。

对于 Merkle Tree 而言，叶子数据更新意味着该叶子节点相关的所有父节点的 hash 值都需要得到更新：

![Merkle Tree 2][mt-up]

更新并不会对 Merkle Tree 的结构造成影响，时间复杂度为 __O(log(n))__。

插入和删除则会改变 Merkle Tree 的结构，如果我现在插入一个新块 data0：

![Merkle Tree 2][mt-ins1]

复杂度也是 __O(log(n))__，但考虑需要满足以下条件：

- 新树在更新叶子数据时 re-hashing 操作的次数控制在 __log(n)__ 以内；
- 新树对数据块的校验次数在 __log(n)__ 以内；
- 除非原始树的 n 是偶数，插入数据后的树没有孤块；如果有，那么孤块是最后一个数据块；
- 数据块的顺序保持一致； 
- 插入后的 Merkle Tree 保持平衡。

所以新 Merkle Tree 的结构应该要这样的：

![Merkle Tree 2][mt-ins2]

新的 Merkle Tree 保持了良好的平衡性，但却几乎重算了整棵 Merkle Tree 的所有节点。
所以对于 Merkle Tree 的插入和删除实际上是一个工程问题，对于不同问题可能会有不同的实现方式。

{% include brline %}

## Merkle Patricia Tree

以太坊中也有使用到 Merkle Tree，也就是一开始讲到的 Merkle Patricia Tree。

站在区块链的角度来看，一笔交易被执行以后就已经是不可逆的。
那么对于区块链而言，储存着交易的树一旦生成，关于树的修改、插入与删除都是无意义的，最重要且最有意义的操作是数据的效验。
而用作储存交易信息的数据结构， Merkle Tree 无疑是最合适的选择。

虽然所有的交易和收据都能采用 Merkle Tree 作为数据结构，但以太坊的区块中不止储存着交易，还有状态(state)。
状态树中储存的数据是可持续发展的，树的叶子是一个 20 字节的地址，该值映射了一个叫作 Account 的对象。
状态树需要频繁地进行写操作：balance 和 nonce 经常需要更新；叶子也会经常插入以及删除。

来看一个例子，假设我们把状态树的结构抽象成这样(不考虑其中的映射与加密)：

![Merkle Tree 2][state-trie]

Account100 的左子节点被删除，右子节点下的一个叶子节点的数据被修改，树的其余部分完全一致。

那么就需要这样一种数据结构，它能在一次插入、更新、删除操作后快速计算到树根，而不需要重新计算整棵树的 hash。
这种数据结构同样得包括两个非常好的第二特征：

- 树的深度是有限制的，不然，攻击者可以通过操纵树的深度，或者执行拒绝服务攻击(DOS attack)，使得区块更新变得极其缓慢。
- roothash 只取决于数据，和其中的更新顺序无关。换个顺序进行更新，甚至从头开始重新计算整棵树也不会改变根的值。

显然，Trie 是最接近同时满足上面的性质的的数据结构，而为了能够更高效地运作，MPT 便是最佳的数据结构。

MPT 的节点按功能和存储的数据可以划分成 4 种类型：

- null：表示空字符串。
- branch：一个长度为 17 的数组 [ v0 ... v15, vt ]，也被称为分支节点。
- leaf：一个长度为 2 的数组 [ encodedPath, value ]。
- extension：一个长度为 2 的数组 [ encodedPath, key ]，与 leaf 不同的是 key 是一个键，用于在数据库中寻值或者通过映射获取更复杂的数据。

### 以太坊中的 MPT

以太坊中所有 Trie 都采用了 MPT 作为数据结构。

这里介绍几个以太坊中被频繁使用到的 Trie：

- StateTrie：储存了所有地址的所有状态，叶子节点为一个 20 字节的地址，该地址与 StorageTrie 具有单射关系。
- StorageTrie：用于储存地址的所有数据，一个地址有且仅有一棵单独的储存树。
- TransactionsTrie：区块中列出的所有交易的交易树，一个区块有且仅有一棵单独的交易树。
- ReceiptsTrie：区块中列出的所有交易收据的收据树，一个区块有且仅有一棵单独的收据树。

它们的 roothash：

- stateRoot：代表整个以太坊的当前状态。
- storageRoot：默认是空值(0x)，代表某个 Account 的当前状态。
- transactionsRoot：代表某区块中所有交易的加密结果。
- receiptsRoot：代表某区块中所有交易收据的加密结果。

{% assign res = page.path | slice: 18,20 | remove: ".md" | prepend: site.res %}

[pat-trie]: {{res}}/pat-trie.png
[mt-node]: {{res}}/mt-node.png
[mt-leaf]: {{res}}/mt-leaf.png
[mt-cmp1]: {{res}}/mt-cmp1.png
[mt-cmp2]: {{res}}/mt-cmp2.png
[DAG]: {{res}}/DAG.png
[mt-up]: {{res}}/mt-up.png
[mt-ins1]: {{res}}/mt-ins1.png
[mt-ins2]: {{res}}/mt-ins2.png
[state-trie]: {{res}}/state-trie.png

[trie]: https://zh.wikipedia.org/wiki/Trie
[radix trie]: https://en.wikipedia.org/wiki/Radix_tree
[merkle tree]: https://en.wikipedia.org/wiki/Merkle_tree
[merkle write]: https://crypto.stackexchange.com/questions/22669/merkle-hash-tree-updates
