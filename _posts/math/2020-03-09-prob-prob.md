---
layout: post
title: 教练，我想学抽卡
categories: mathematics
tags: mathematics probability arknight
date: 2020-03-09
katex: true
---

事情是这样的最近开始玩明日方舟了，作为一个脸黑又贫穷的博士，如何使用有限的资源，
使得自己的抽卡逻辑达到理论上的一个较优解，从而实现利益最大化，是一个可以深究的问题，故此研究一下其中的概率问题。

## 骰子概率问题

一个正 m 面体骰子，考虑每次投掷时任意一面出现的概率均为 $1/m$，且每次投掷时单次概率基数不变。

骰子投 1 次时某一数字已出现过的概率：

$$
P_1 = \frac{m^0}{m^1}
$$

骰子投 2 次时某一数字已出现过的概率：

$$
P_2 = \frac{m^1 + (m-1) \times \boldsymbol{m^0}}{m^2}
$$

骰子投 3 次时某一数字已出现过的概率：

$$
P_3 = \frac{m^2 + (m-1) \times \boldsymbol{(m^1 + (m-1))}}{m^3}
$$

骰子投 4 次时某一数字已出现过的概率：

$$
P_4 = \frac{m^3 + (m-1) \times \boldsymbol{(m^2 + (m-1) \times (m^1 + (m-1)))}}{m^4}
$$

骰子投 n 次时某一数字已出现过的概率可归纳为：

$$
P_n 
= \frac{m^{n-1} + (m-1) \times \boldsymbol{(P_{n-1} \times m^{n-1})}}{m^n}
= \frac{1 + (m-1) \times P_{n-1}}{m}
$$

{% highlight python %}
def P(m, n, f):
    if n == 0:
        return 0
    else:
        return (1 + (m - 1) * f(m, n - 1, f)) / m


if __name__ == '__main__':
    prob = P(6, 2, P)
    print(prob) # => 0.3055555555555556
{% endhighlight %}

{% include brline %}

## 抽卡概率问题

骰子的概率问题可以很容易就引申并推广到抽卡的概率问题，某一类可能抽到的卡就是骰子的其中一或多面，
更高的概率意味着占据了更多的面数。

规则如下：你每抽一次，更稀有的品质将提升一定的概率百分比，那么该规则即可归纳如下 ——
一个正 m 面体骰子，每骰一次其中一面就会变成更稀有的数字，然后将使用该骰子进行新一轮的投掷。

骰子投 1 次时你想要的数字已出现过的概率：

$$
Q_1 = \frac{m^0}{m^1}
$$

骰子投 2 次时你想要的数字已出现过的概率：

$$
Q_2 = \frac{m^1 \times 2 + (m-2) \times \boldsymbol{m^0}}{m^2}
$$

骰子投 3 次时你想要的数字已出现过的概率：

$$
Q_3 = \frac{m^2 \times 3 + (m-3) \times \boldsymbol{(m^1 \times 2 + (m-2))}}{m^3}
$$

骰子投 4 次时你想要的数字已出现过的概率：

$$
Q_4 = \frac{m^3 \times 4 + (m-4) \times \boldsymbol{(m^2 \times 3 + (m-3) \times (m^1 \times 2 + (m-2)))}}{m^4}
$$

骰子投 n 次时你想要的数字已出现过的概率：

$$
Q_n
= \frac{m^{n-1} \times n + (m-n) \times \boldsymbol{(Q_{n-1} \times m^{n-1})}}{m^n}
= \frac{n + (m-n) \times Q_{n-1}}{m}
$$

{% highlight python %}
def Q(m, n, f, diff=0):
    if n == 0:
        return 0
    else:
        # diff 默认为 0，nt 和 diff 是为了和我下面要讲的东西做兼容
        nt = n - diff
        return (nt + (m - nt) * f(m, n - 1, f, diff)) / m


if __name__ == '__main__':
    prob = Q(6, 2, Q)
    print(prob) # => 0.4444444444444444
{% endhighlight %}

抽卡概率问题实际上是骰子概率问题的一个更广义版本，那么两项归纳后的公式如此相似也是意料之中。

{% include brline %}

## 抽卡的正确姿势？

我似乎发现了一个能够以相对少的资源抽取资深干员的高性价比抽卡策略。

首先明日方舟的抽卡概率是这样规定的： $6\bigstar$ 占标准寻访概率的 $2\%$，
如果累计寻访 50 次没有获得 $6\bigstar$ 干员，则从下一次开始每一次较上一次提高 $2\%$，即 $1 \over 50$，
也就是第 100 次出 $6\bigstar$ 的概率可以达到 $100\%$。

前 50 次就可以抽到 $6\bigstar$ 的概率可以用上面第一条公式算出，
而 50 次以后才抽到 $6\bigstar$ 的概率则可以用上面第二条公式算出。

{% highlight python %}
def yjprob(m, n, f, diff):
    if n == 0:
        return 0
    if n == 100:
        return 1
    elif n <= diff:
        return P(m, n, P)
    else:
        return Q(m, n, yjprob, diff)


if __name__ == '__main__':
    # diff: 第 50 次开始概率增加
    # m: 单抽 6* 的概率为 2%，理解为一个正 50 面体的骰子的面数
    # n: 抽的总次数
    diff, m, n = 50, 50, 60
        
    prob = yjprob(m, n, None, diff)
    print(prob) # => 0.8887952002031017
{% endhighlight %}

连续 60 抽能抽到 $6\bigstar$ 的概率竟高达 $88.88\%$。

### __期间我共能抽多少次？__

由于 yj 的标准卡池每两周换一次，按开服到现在的更新速度基本上两个月出新的 $6\bigstar$ 干员。
每次卡池都有 10 次以内保底 $5\bigstar$，按两个月换 4 轮卡池，脸黑的博士即使每次抽到保底也共 40 抽。
等到出了新卡池后，别忘了新卡池也是有保底的，换言之前 50 抽都是必得 5 个 $5\bigstar$ 保底，
这时，再下一次的十连你能拥有高达 $88.88\%$ 的概率能够得到新的 $6\bigstar$ 干员。

如果你不贪抽，保底即止，屯了两个月的合成玉，按普普通通月卡号来算：
- 4 次标准卡池轮换共 8 周，新卡池持续时间为 2 周，共 10 周 70 天，
- 每周任务可白嫖 500 合成玉，每周剿灭作战奖励 1700 合成玉，
- 每日任务可白嫖 100 合成玉，再加上月卡提供每日 200 合成玉，
- 期间每次更换卡池闪断更新邮件补偿 200 合成玉，加总 800 合成玉，
- 合计 $10 \times 2200 + 70 \times 300 + 800 = 43800$ 合成玉。
