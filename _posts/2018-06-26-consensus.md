---
layout: post
title: 分布式共识
category: Algorithm
date: 2018-06-26
---

如果你想要定制一个联盟/私有链，要求该链交易成本更低/高，交易延时更低/高，拥有完全的控制权/完全去中心化，
什么样的共识协议才能满足你的需求？或者说什么样的共识协议才是最佳的选择方案？

<br />

---

<br />

## 工作量证明(Proof-of-Work)

PoW 共识，也是最广为人知的一种共识，工作量的多少是证明节点清白的唯一手段，同时也是节点间彼此信任达成共识的唯一手段。
如果在计算完成后关于新区块的 hash 值存在分歧，那么总是信任总计算量更大的节点。

工作量证明是最早被发明出来并切实可行的 P2P 共识方案，也是目前唯一能够做到完全中心化的共识方案。
这个概念首次在 2008 年，由 Satoshi 发表的一篇名为 ["Bitcoin: A Peer-to-Peer Electronic Cash System"][bitcoin whitepaper] 的论文中被提出。

### 首次应用

2009 年 1 月 3 日，世界上第一个区块链应用以及去中心化货币 Bitcoin 诞生。
Satoshi 在 Bitcoin 的区块生成过程中使用了这种共识机制，一个符合要求的块区 hash 由 N 个前导零构成，零的个数取决于网络的难度值。
要得到合理的块区 hash 需要经过大量随机尝试计算，计算时间取决于机器的哈希运算速度。

当某个节点提供出一个合理的 hash 值，说明该节点确实经过了大量的尝试计算，当然，并不能得出计算次数的绝对值，因为寻找合理 hash 是一个概率事件。
当节点拥有占全网 n% 的算力时，该节点即有 n/100 的概率找到区块 hash。

这是人类在分布式共识领域中迈出的第一步，也是最重要的一步，再次感谢 Satoshi 发明了这个东西。

### 不足之处

- PoW 存在 51% 攻击问题，恶意挖矿者超过全网算力的 51% 后基本上就能完全控制整个网络。
- 虽然已上链的数据无法被更改，但恶意挖矿者仍然可以做一些 DoS 攻击。
- 所有相同创世块的旷工都能随时加入网络，潜在的安全隐患会长期存在。
- 大量的电力资源消耗也是需要作为后续成本考虑。

<br />

---

<br />

## 权益证明(Proof-of-Stake)

PoW 并非完美，其中被指责最多的主要有两点，一是浪费能源，二是风险和收益博弈必然导致联合挖矿，而大算力矿池可能会对系统的去中心化构成威胁。

2011 年，一个名为 Quantum Mechanic 的数字货币爱好者在 Bitcointalk 论坛提出 Proof-of-Stake 的共识机制，该机制被充分讨论之后证明其具有可行性。
如果说 PoW 主要比拼算力，算力越大，挖到一个块的概率越大，那 PoS 就是比拼余额，即手里的币越多，挖到一个块的概率越大。

这意味着发表一条消息的时候，不用证明你付出了什么代价，而需要证明你拥有一定数量的钱；
而如果你作弊损害了这个系统的安全性，你的钱会贬值，这变相地让你付出了代价。

PoS 可以解决 Pow 的部分问题：

- 由于不需要矿工持续地进行挖矿产生区块记录，更能节省电力；
- 在 PoS 的共识理论下，越有钱的人，作弊付出的代价就越大，所以 51% 攻击在 PoS 是不可行的。

### 不足之处

PoS 从控制权、安全考虑以及运营方面仍有欠缺：

- PoS 仍然允许任何符合条件的旷工加入，对于没钱的人而言，他们没代价可付，所以一些**恶意行为**对于他们是有益的。
- 持有量越多获得奖励的可能也越大，有可能会出现屯币现象，降低货币流通量。

> 这种恶意行为又叫作 **nothing-at-stake attack(无利益攻击)**。

### 实现方案

在 PoW 中能够影响共识结果的唯一因素是工作量，也就是说 PoW 的应用手段总是离不开大量的计算。 
而 PoS 的设计需要一项具体的经济学模型或假说支撑其理论，算法的可靠性依赖于其背后的经济学理论。
由于无需再拘泥于工作量本身，PoS 共识能够具体出多种不同的实现方案。
下面给当下一些比较知名的 PoS 策略作一些简单介绍。

### Casper

Casper 是以太坊设计的一套 PoS 共识协议，是一种基于保证金的经济激励共识协议，一种 PoW 在 PoS 上的变体。
由于 Casper 实际上是一棵 **GHOST**，因此 Casper 又被称为友善的小精灵(the friendly ghost)。

> GHOST：Greedy Heaviest-Observed Sub-Tree(贪心最重观察子树)

共识协议最大的威胁之一就是矿工形成以损害非成员利益为代价最大化成员获利的集团，而 Casper 将共识过程看作一个[合作博弈][cooperative theory]：

- Casper 协议中的节点，作为锁定保证金的验证人(bonded validators)，必须先缴纳保证金(bonding)才可以参与出块和共识形成；
- 如果一个验证人作出了任何 Casper 认为无意义的事情，他的保证金将被罚没，出块和参与共识的权利也会被取消。

保证金的引入解决了 nothing-at-stake，也就是经典 PoS 协议中做坏事的代价很低的问题。

#### 下注共识(Gambling-on-Consensus)

Casper 要求验证人将保证金中的大部分对共识结果进行下注。而共识结果又通过验证人的下注情况形成：

- 验证人必须猜测其他人会赌哪个块胜出，同时也下注这个块；
- 如果赌对了，就可以拿回保证金外加交易费用，如果赌错了，你将失去你的保证金；
- 如果没有在一定时间内达成一致，只能拿回部分保证金。

数个回合之后验证人的下注分布就会收敛。这也是为什么说 Casper 是一种 PoW 在 PoS 上的变体，如果把 PoW 也想象成一种下注机制：

- 当出现分叉时，矿工选择一个块基于它进行开采，也就是赌这个块会成为主链的一部分；
- 如果赌对了，你将得到奖励，如果赌错了，将会损失电费；
- 只要大部分的矿工都将算力下注到正确的链上，使这条链拥有最多的工作量，共识就是安全的。

PoW 的赌注会随着确认数的增加**线性增加**，而 Casper 的验证人可以通过协调使下注比例**指数增长**。
除了更节省电力，还能使共识能够以最快速达到最大安全。

### 委任权益证明(Delegated Proof-of-Stake)

DPoS 是 BTS/EOS 采用的一种共识协议，是一种类似股东议会制度或人民代表大会制度的投票机制。
实际上这是解决 Nothing-at-stake attack 的另一种方式——只有有钱才能参加共识。

所以，DPoS 的本质是一个中心化的共识机制。

<br />

---

<br />

## 权威证明(Proof-of-Authority)

PoA 的概念由以太坊和 Parity Technologies 的联合创始人 Gavin Wood 所提出，PoA 采用了一种授权签名的方式达成共识：

- 创始块依靠预设好的 signer(已获得授权的 miner) 负责产生区块；
- 在区块的生产过程中可以通过现有的 signer 投票选举出新的 signer；
- 现有的 signer 也可以投票踢出恶意的 signer。

> 投票需要超过 50% 的同意。

以太坊的区块中包含了一个叫作 `Header` 的数据，在 PoA 共识下，所有授权的 signer 都被保存在其中一个叫作 `Extra` 的字段中。
`Extra` 包含所有签名者列表和当前签名者对该区块的签名数据(可以恢复出来签名者的地址)。

> 保存到 `Extra` 中而非引入新的字段的目的在于在避免改变核心数据结构的情况下直接引进新的功能。

任意高度的区块都有且仅有一个 signer 处于一个 $$\text{IN-TURN}$$ 的状态(相当于 leader)，其它的 signer 则处于被称为 $$\text{OUT-OF-TURN}$$ 的状态。
leader 签名的块会立即广播，其它 signer 签名的块会延时一段随机时间后广播，保证 leader 签名的块有更高的优先级上链。

为避免出现同一个 signer 能够在短期内频繁地签名并广播区块的情况，PoA 对签名作出了一点限制：
$$\newcommand{absR}{|R|}$$

1. 所有 signer 轮询成为 leader；
2. 如果用 $$R$$ 表示所有 signer，那么同一个 signer 只能签名每 $$\frac{\absR}{2} + 1$$ 个块的其中一个。

当 $$\absR = 10$$，signer $$N$$ 签名了第 4 个 pending 块，则 $$N$$ 在到达第 7 块时能恢复继续参与签名区块的能力($$\frac{\absR}{2} + 1 = 6 \lt 7$$)。

### 不足之处

由于只有部分授权的 signer 才能够对区块行使签名，而没有授权的矿工则失去了挖矿的意义。
而普通矿工想要成为 signer 不仅需要经过漫长的投票等待，能否被其它 signer 信任又是一个问题。

如果一个攻击者处心积虑使自己控制的节点占有 signer 列表的大部分，这和 51% 攻击的问题是类似的。

<br />

---

<br />

## 拜占庭容错(Byzantine Fault Tolerance)

一个安全的分布式计算和多代理系统，或者说一个具有较高可靠性的共识协议，它首先必须是可容错的。

这里首先会简单讨论下不可解的**两位将军问题**，再引申到**拜占庭将军问题**和分布式系统中的**容错问题**以及**实用拜占庭容错(pBFT)**。

### 两位将军问题(Two General's Problem)

![2 generals problems][2-generals]

- 有两支军队一起攻打一座城市，他们各自占领城市附近两边不同的山谷，且各由一名将军领导。
- 两军之间隔着一个山谷，双方唯一的通信方式就是派遣信使来往于三个山谷。中间山谷已被城市保卫军占领，信使在通过山谷时可能会被捕。
- 现在两支军队要协商进攻城市的时间，因为只有两支军队一起进攻才能获得战斗的胜利。他们必须约定一个时间点，并就在那时发动攻击。

将军们就攻击时间达成共识非常简单，在安全方面将军们可以使用签名的方法防止敌军对消息进行伪造。
但两位将军问题的微妙之处在于无法设计出一种可靠的算法能够为将军提供可靠的商定手段：

1. 约定时间的将军发送了消息，但是他无法确定发送是否成功到达——除非他收到了确认的回复。因此，他就会犹豫是否对敌军发起进攻。
2. 确认消息的将军进行了回复，但他也无法确定回复是否成功到达——除非他收到了确认的回复。因此，他也会犹豫是否对敌军发起进攻。

由於无法 100% 确定消息成功是否到达，两位将军只能在第 2 步不断重复，战况陷入了僵局。
这背后其实有一个著名的定理：**FLP不可能性**。它描述了在分布式异步通信中，没有任何算法能完全保证系统的一致性。

**两位将军问题已被证实无解。
但两位将军问题的不可解决性也仅限处于具有不安全、不可靠的通信环境的完全异步分布式系统中才成立。**

两位将军问题与网络连接都有着极为相似的安全隐患以及不可靠的通信通道，那么 **TCP(三次握手)** 又是如何建立起网络连接的呢？
原则上上 TCP 也是不可靠的——在网络连接期间两个打开的端口只能每隔一段时间定时去发送数据包以确定对方的状态。
所以实际上 TCP 上的所有东西都是不可靠的，不管是 CDN 还是 P2P，任何分组交换网络都是不可靠的。

虽然科学告诉你什么是可能以及不可能，但是工程能告诉你，付出一些代价，不可能也可以变成可能：
- 学术定理遵循的是严格的数学证明，考虑的是最极端的情况；
- 在工程实践中，学术上的极端性一般情况下很少发生，即便发生，重试几次也就好了。

譬如，每次都派出多名信使，将不可靠性消减到一个可以接受的程度。或者干脆成立一个中心化的通信枢纽，通信完全交给第三方进行协调。

### 拜占庭将军问题(Byzantine General's Problem)

["拜占庭将军问题"][byzantine generals problem]是由 Lamport、Shostak 和 Pease 于 1982 年提出的一个用于解释一致性问题的虚构模型：

- 拜占庭军队的几个师在一个敌人城市外扎营，每个师都有自己将军指挥，将军们只能通过信使互相沟通。
- 在观察敌人后，将军们决定采用共同的计划行动。然而，一些将军可能是叛徒，试图阻止忠诚的将军达成共识。

这是两位将军问题的一个带反转的广义版本，它描绘了同样的场景，但增加了一层复杂性：其中一个或几个将军有可能是叛徒，叛徒可以选择说谎。

那么将军们想要达成共识必须有一个算法来保证：

1. 所有忠诚的将军都会采取同样的行动计划；
2. 在叛徒占少数的情况下，忠诚的将军将不会采取糟糕的计划。

无论叛徒做什么，算法都必须保证条件 1 满足。但条件 2 很难正式化，因为它需要准确地推测出错误的计划是什么。

### 拜占庭容错(Byzantine Fault Tolerance)

拜占庭将军问题的解需要遵循一个定理：对于任意 $$m$$，如果有多于 $$3m$$ 的将军和至多 $$m$$ 个叛徒，那么算法 $$\text{OM}(m)$$ 达到共识。

此时，达成共识的算法将基于将军所观察到的其它大多数人的决策。如果将军们在有叛徒存在的情况下仍然达成了一致，那么就称达到了**拜占庭容错**。

拜占庭容错是一种系统的特征，它定义了该系统可以容忍 **拜占庭故障(Byzantine Failure)** 类别的故障模式。

> 拜占庭故障：属于拜占庭将军问题的一类故障，拜占庭故障是最为困难的一类故障模式。

拜占庭故障是最严重最难处理的故障之一。在飞机发动机系统、核电站和几乎所有行为取决于大量传感器结果的系统都需要拜占庭容错。

### 实用拜占庭容错(Practical Byzantine Fault Tolerance)

在分布式系统的环境中，BFT(拜占庭容错) 一直是分布式网络的重点研究对象，目前这项技术已经在大量的实践中拥有了不少的优秀的优化版本。

pBFT(实用拜占庭容错) 正是其中的众多优化之一，于 Castro 和 Liskov 于 1999 年发表的论文 ["Practical Byzantine Fault Tolerance"][pBFT] 中被提出。
该算法旨在异步系统中工作，经过优化，具有开销运行时的高性能，并且只有轻微的延迟增加。

pBFT 模型主要侧重于提供实用的拜占庭**状态机复制**。状态机通常被定义为一个多值元组：$$\langle s,i,o,t,f,start \rangle$$。

- $$s$$: 一组状态。
- $$i$$: 一组输入。
- $$o$$: 一组输出。
- $$t$$: 一个转换函数，$$t(i, s) \rightarrow s'$$。
- $$f$$: 一个输出函数，$$f(i, s) \rightarrow o$$。
- $$start$$: 一个初始的状态。

一个拜占庭状态机从『初始』开始，在新的输入被接收到前，状态保持不变。每一次输入都会传入转换函数和输出函数，以生成一个新的状态和输出。

通过假设存在故障节点时由特定独立的节点操纵信息的传播来容忍拜占庭故障。
所有节点按顺序排序、彼此通信，不仅需要证明消息来自特定的对等节点，还需要验证消息在传输过程中是否未被修改，使所有诚实节点达成状态一致。

> pBFT 模型中的特定节点为主节点(leader)，其它节点称为备份节点。

![pBFT str][pBFT-str]

为了使 pBFT 模型起到实际作用，故障的节点数量不能等于或超过系统中总节点数的 $$1 \over 3$$。但只要不超过这个数量，该算法就能有效地提供安全性。

### 不足之处

如果用 $$R$$ 表示所有的状态机副本，那么就有允许故障的最大节点数 $$u$$。

$$u = \frac{\absR - 1}{3}$$

假设 $$v$$ 是实际的故障节点数，那么就有达成共识所需的最少副本数 $$S$$。

$$S = 3v + 1$$

且有：

$$
\begin{align}
v &\leq u
\\
S &\leq \absR 
\end{align}
$$

而现实中，很少会刚好同时存在着 $$u$$ 个故障节点，那么就多出来了 $$p$$ 个无用的状态机副本。

$$p = \absR - S$$

多出额外的 $$p$$ 个副本将会影响到整体共识过程的性能。

<br />

---

<br />

## Paxos

Paxos 协议于 1989 年首次发布，并以希腊 Paxos 岛上使用的虚构立法共识系统命名，是一系列用于在不可靠处理器网络中解决共识的协议。
一系列的意思即字面意思，假设当前场景下能够满足 Paxos 的前置假设，那么：

1. 列举出一些场景，使得 Paxos 无法再满足一致性。
2. 接着再丰富 Paxos 的协议流程使得能够满足该场景。
3. 重复 1 和 2。

通过对协议流程不断地改进，使得在任意场景下 Paxos 都能够保证系统的一致性，最终就得到了一套强大的 Paxos 协议。

### 角色(Roles)

在共识的过程中，所有参与了共识的分布式节点都被分配了不同动作，Paxos 协议使用了不同的角色来描述这些不同的动作：

- **Client**：向分布式系统发出请求，并等待响应。
- **Proposer**：接收到请求后发起 **Proposal**，在发生冲突时充当协调员推进协议。
- **Acceptor**：协议中的容错载体，会被收集到一个 **Quorums** 组中。
- **Learner**：协议的复制因子，一旦 Client 的请求得到 **Accept** ，那么 Learner 就可以获得一个 **Action**。
- **Leader**：从 Proposer 中选出的领导者。

> Acceptor 只能接收来自 Quorums 中的消息。
>
> 若某个 Proposal 获得了多数 Acceptor 的同意，则称被 Accept。
>
> Learner 只能获得被 Accept 的提案。

在经典的 Paxos 部署中，一个节点往往能够同时扮演一个或多个角色，并且多数时候都在同时扮演 Proposer、Acceptor、Learner 这三个角色。

### 不足之处

- **传统 Paxos 协议需要满足一个前置假设：系统的环境是安全的，并不存在恶意的节点。**

  Paxos 设计的初衷在于给大型企业服务器提供一种完全异步的分布式系统，虽然同样是为了解决分布式系统中的共识难题，
  但 Paxos 最终解决的还是由于服务器的异步消息发送或者出现了网络故障、延迟等导致消息出现的先后各异或干脆丢失等问题。

  也就是说要求系统不一定可靠，但一定安全，更正式的说即要求**系统无拜占庭将军问题**。
  这导致了纵使 Paxos 能够极快地形成共识，但是却不适合作为大多数公链的共识算法来使用，而只能在一些私链上进行部署。

  > Lamport 对此又提出了一种 Byzantine Paxos 的方案来解决这个问题。

- **适用性低，实现的变数大。**

  Paxos 拥有非常之多的变体，在不同的系统中往往需要满足不同的需求，无法统一的实现方案给移植带来了困难。
  
  这导致了只有部分专业人士才能在系统上进行部署，门槛较高。

<br />

---

<br />

## Raft

Raft 是一个用于实现分布式共识的协议，其共识过程可以简单地概括为
**通过一种可靠的投票机制选举出一个 Leader 作为中央节点，所有对系统的改变都会在 Leader 的指挥下有序地完成。**
也就是说 Raft 是一个中心化的共识算法。

当 Leader 出现问题无法继续胜任自己工作时，剩下的节点会迅速投票选举出下一个 Leader。
这种做法有效地解决了传统架构的系统中主服务器出现系统故障时的问题，间接提高系统整体的可靠性及高容错性。

### 领导选举(Leader Election)

Raft 的节点能够处于以下 3 种状态中的一种：

- Leader：系统中的主节点。
- Follower：系统中的其余节点。
- Candidate： Leader 失效后，成为了 Leader 候选者的 Follower 节点。

所有节点都从 Follower 开始，成为 Candidate 的节点会请求其它 Follower 节点为它投票，获得了多数票数后即可成为 Leader。

### 日志复制(Log Replication)

当客户端发送消息给服务器时，消息最优先经过 Leader。但 Leader 不会马上进行处理，而是将其作为一个 entry 添加到**节点日志**中。
一条 entry 在未执行提交前不会对系统作出任何改变。

之后，Leader 会将这条 entry 同步给所有 Follower，Follower 收到消息同样会更新自己的节点日志。
如果大多数 Follower 都完成了操作并返回了回调，那么提交就完成了。
接下来 Leader 会执行这项 entry 并更新系统的状态，并通知所有 Follower 更新自己的系统状态。

通过这种日志复制的操作，分布式集群能够很简单且快速就系统状态方面达成共识。

### 不足之处

通过随机的变数使随机的节点成为 Candidate 并选举为 Leader，之后的共识完全交给 Leader 完成，那么当出现恶意节点时，整个系统基本完蛋。
也就是说 Raft 同样要求**系统无拜占庭将军问题**。

<br />

---

<br />

## 总结

共识算法的选择与应用场景高度相关，可信环境使用 Paxos 或者 Raft，带许可的联盟链可使用 pBFT，非许可链可以是 PoW、PoS、ripple 等。
根据信任度分级，自由选择共识机制，此为最优。

{% assign img_url = "/images/consensus" %}

[2-generals]: {{img_url}}/2-generals.svg
[pBFT-str]: {{img_url}}/pBFT-str.jpg

[bitcoin whitepaper]: https://bitcoin.org/en/bitcoin-paper
[cooperative theory]: https://en.wikipedia.org/wiki/Cooperative_game_theory
[byzantine generals problem]: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.9525&rep=rep1&type=pdf
[state machine replication]: https://en.wikipedia.org/wiki/State_machine_replication
[pBFT]: http://pmg.csail.mit.edu/papers/osdi99.pdf 
