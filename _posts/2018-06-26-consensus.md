---
layout: post
title: 分布式共识
category: algorithm
date: 2018-06-26
---

如果你想要定制一个联盟/私有链，并要求该链交易成本更低/高甚至没有，交易延时更低/高，并发更低/高，
拥有完全的控制权/完全去中心化，什么样的共识协议才能满足你的需求？或者说什么样的共识协议才是最佳的选择方案？

<br />

---

<br />

## 工作量证明(Proof-of-Work)

PoW 共识，也是最广为人知的一种共识，工作量的多少是证明节点清白的唯一手段，同时也是节点间彼此信任达成共识的唯一手段。
如果在计算完成后新区块的 hash 值存在分歧，那么总是信任总计算量更大的节点。

工作量证明是最早被发明出来并切实可行的 P2P 共识方案，也是目前唯一能够做到完全中心化的共识方案。
这个概念首次在 2008 年，由 Satoshi 发表的一篇名为 ["Bitcoin: A Peer-to-Peer Electronic Cash System"][bitcoin whitepaper] 的论文中被提出。

### 首次应用

2009 年 1 月 3 日，世界上第一个区块链应用以及去中心化货币 **Bitcoin** 诞生。
Satoshi 在 Bitcoin 的区块生成过程中使用了这种共识机制，一个符合要求的块区 hash 由 N 个前导零构成，零的个数取决于网络的难度值。
要得到合理的块区 hash 需要经过大量随机尝试计算，计算时间取决于机器的哈希运算速度。

当某个节点提供出一个合理的 hash 值，说明该节点确实经过了大量的尝试计算，当然，并不能得出计算次数的绝对值，因为寻找合理 hash 是一个概率事件。
当节点拥有占全网 n% 的算力时，该节点即有 n/100 的概率找到区块 hash。

这是人类在分布式共识领域中迈出的第一步，也是最重要的一步，再次感谢 Satoshi 发明了这个东西。

### 不足之处

- PoW 存在 51% 攻击问题，恶意挖矿者超过全网算力的 51% 后基本上就能完全控制整个网络；
- 虽然链无法被更改，已上链的数据也无法更改，但恶意挖矿者仍然可以做一些 DoS 攻击；
- 考虑到具有相同创世块的旷工都能加入你的网络，潜在的安全隐患会长期存在；
- PoW 大量的电力资源消耗也是需要作为后续成本考虑。

<br />

---

<br />

## 权益证明(Proof-of-Stake)

PoW 并非完美，其中被指责最多的主要有两点，一是浪费能源，二是风险和收益博弈必然导致联合挖矿，而大算力矿池可能会对系统的去中心化构成威胁。

2011 年，一个名为 Quantum Mechanic 的数字货币爱好者在 Bitcointalk 论坛提出 Proof-of-Stake(PoS) 证明机制，该机制被充分讨论之后证明具有可行性。
如果说 PoW 主要比拼算力，算力越大，挖到一个块的概率越大，那 PoS 就是比拼余额，即手里的币越多，挖到一个块的概率越大。

这意味着发表一条消息的时候，不用证明你付出了什么代价，而需要证明你拥有一定数量的钱；
而如果你作弊损害了这个系统的安全性，你的钱会贬值，这变相地让你付出了代价。

PoS 可以解决 Pow 的部分问题：

- 由于不需要矿工持续地进行挖矿产生区块记录，更能节省电力；
- 在 PoS 的共识理论下，越有钱的人，作弊付出的代价就越大，所以 51% 攻击在 PoS 是不可行的。

在 PoW 中能够影响共识结果的唯一因素是工作量，也就是说 PoW 的具体实现总是离不开大量的计算。 
但 PoS 的设计总是需要一个具体的经济学模型或假说作为其理论支持，算法的可靠性依赖于其背后的经济学。
而共识算法是一种设计思想，由于无需再拘泥于工作量本身，因此 PoS 算法能够具体出多种不同的实现方案。
下面会对于时下的几种不同的 PoS 策略进行逐一讲解。

### 不足之处

PoS 从控制权、安全考虑以及运营方面仍有欠缺：

- PoS 仍然允许任何符合条件的旷工加入，对于没钱的人而言，他们没代价可付，所以一些**恶意行为**对于他们是有益的；
- 持有量越多获得奖励的可能也越大，有可能会出现屯币现象，降低货币流通量。

> 这种恶意行为又叫作 **nothing-at-stake attack(无利益攻击)**。

### Casper

Casper 是以太坊设计的一种 PoS 共识协议，是一种**基于保证金的经济激励共识协议**，一种 PoW 在 PoS 上的变体。
Casper 又被称为**友善的小精灵(the friendly ghost)**，因为它实际上是 **GHOST**。

> GHOST：Greedy Heaviest-Observed Sub-Tree(贪心最重观察子树)

共识协议最大的威胁之一就是矿工形成以损害非成员利益为代价最大化成员获利的集团，而 Casper 将共识过程看作一个[合作博弈][cooperative theory]：

- Casper 协议中的节点，作为**锁定保证金的验证人(bonded validators)**，必须先**缴纳保证金(bonding)**才可以参与出块和共识形成；
- 如果一个验证人作出了任何 Casper 认为**无意义**的事情，他的保证金将被罚没，出块和参与共识的权利也会被取消。

保证金的引入解决了 nothing-at-stake，也就是经典 PoS 协议中做坏事的代价很低的问题。

#### 下注共识(Gambling-on-Consensus)

Casper 要求验证人将保证金中的大部分对共识结果进行下注。而共识结果又通过验证人的下注情况形成：

- 验证人必须猜测其他人会赌哪个块胜出，同时也下注这个块；
- 如果赌对了，就可以拿回保证金外加交易费用，如果赌错了，你将失去你的保证金；
- 如果没有迅速达成一致，只能拿回部分保证金。

数个回合之后验证人的下注分布就会收敛。这也是为什么说 Casper 是一种 PoW 在 PoS 上的变体，如果把 PoW 也想象成一种下注机制：

- 当出现分叉时，矿工选择一个块基于它进行开采，也就是赌这个块会成为主链的一部分；
- 如果赌对了，你将得到奖励，如果赌错了，将会损失电费；
- 只要大部分的矿工都将算力下注到正确的链上，使这条链拥有最多的工作量，共识就是安全的。

PoW 的赌注会随着确认数的增加**线性增长**，而 Casper 的验证人可以通过协调使下注比例**指数增长**。
除了更节省电力，还能使共识能够以最快速达到最大安全。

### 委任权益证明(Delegated Proof-of-Stake)

DPoS 是 BTS/EOS 采用的一种共识协议，是一种类似股东议会制度或人民代表大会制度的投票机制。
实际上这是解决 **Nothing-at-stake attack** 的另一种方式——只有有钱才能参加共识。

所以，DPoS 的本质是一个中心化的共识机制。

<br />

---

<br />

## 权威证明(Proof-of-Authority)

PoA 的概念由以太坊和 Parity Technologies 的联合创始人 Gavin Wood 所创造，采用了一种授权签名的方式达成共识：

- 创始块依靠预设好的 signer(已获得授权的 miner) 负责产生区块；
- 在区块的生产过程中可以通过现有的 signer 投票选举出新的 signer；
- 现有的 signer 也可以投票踢出恶意的 signer。

> 投票需要超过 50% 的同意。

以太坊的每个区块中都包含了一个叫作 `Header` 的数据，在 PoA 共识算法下，所有授权的 signer 都被保存在其中一个叫作 `Extra` 的字段中。

> `Extra` 包含所有签名者列表和当前签名者对该区块的签名数据(可以恢复出来签名者的地址)。
> 保存到 `Extra` 中而非引入新的字段的目的在于在避免改变核心数据结构的情况下直接引进新的功能。

任意高度的区块都有且仅有一个 signer 处于一个 `IN-TURN` 的状态(相当于 leader)，其它的 signer 则处于被称为 `OUT-OF-TURN` 的状态。
leader 签名的块会立即广播，其它 signer 签名的块会延时一段随机时间后广播，保证 leader 签名的块有更高的优先级上链。

> 在不考虑网络因素以及出现分叉的情况下，leader 签名的区块更有可能成功上链。

为避免出现同一个 signer 能够在短期内频繁地签名并广播区块的情况，PoA 对签名作出了一点限制：

1. 所有 signer 轮询成为 leader；
2. 如果将所有 signer 组成的集合用 `R` 表示，那么同一个 signer 只能签名每 `|R|½ + 1` 个块的其中一个。

如果在第 4 个块时 `|R| ≡ 10` 为真，signer `N¹` 此时签名 pending 块，即使第 5 个块的 leader 出于某种原因无法签名，`N¹` 也无法对该块进行签名。
到第 7 个块时，如果 `|R| ≤ 10` 仍然为真，则 `N¹` 恢复继续参与签名区块的能力(`10½ + 1 < 7`)。

### 不足之处

由于只有部分给与授权的 signer 才能够对区块行使签名，那对于没有授权其它的 miner 而言挖矿便成了没有意义的事情。
没有激励机制即意味着矿工数量会减少，而想要成为 signer 不仅需要经过漫长的投票等待，是否被其它 signer 信任又是一个问题。

同时，如果一个攻击者处心积虑使自己控制的节点占有了 signer 列表的大多数，即意味着它可以完全控制整个网络。

> 攻击者能够随意踢出/假如 signer 列表，或者签名任意区块。

<br />

---

<br />

## 拜占庭容错(Byzantine Fault Tolerance)

一个安全的分布式计算和多代理系统，或者说一个具有较高可靠性的共识协议，它首先必须是可容错的。

这里首先简单地讨论下不可解的**两位将军问题**，再引申到**拜占庭将军问题**和分布式系统中的**容错问题**以及**实用拜占庭容错(pBFT)**。

### 两位将军问题(Two General's Problem)

<p align="center">
    <img src="/images/consensus/2-generals.svg"/>
</p>

> 有两支军队一起攻打一座城市，他们各自占领城市附近两边不同的山谷，且各由一名将军领导。
> <br />
> 两军之间隔着一个山谷，双方唯一的通信方式就是派遣信使来往于三个山谷。中间山谷已被城市保卫军占领，信使在通过山谷时可能会被捕。
> <br />
> 现在两支军队要协商进攻城市的时间，因为只有两支军队一起进攻才能获得战斗的胜利。他们必须约定一个时间点，并就在那时发动攻击。

将军们就攻击时间达成共识非常简单，在安全方面将军们可以使用签名的方法防止敌军对消息进行伪造。
但**两位将军问题**的微妙之处在于无法设计出一种可靠的算法能够为将军提供可靠的商定手段：

1. 其中一个将军约定了时间并发送了消息，但是他无法确定消息是否成功到达——除非他收到了确认的回复。因此，他就会犹豫是否对敌军发起进攻。
2. 收到消息的将军确认后对此进行了回复，但他也无法确定回复的消息是否成功到达——除非他也收到了确认的回复。因此，他也会犹豫是否发起进攻。

由於无法 100% 确定消息成功是否到达，两位将军的心境都在 **1** 与 **2** 间不断来回，战况陷入了僵局。
这背后其实有一个著名的定理：**FLP不可能性**。它描述了在分布式异步通信中，没有任何算法能完全保证系统的一致性。

**两位将军问题已被证实无解。**

> 两位将军问题的不可解决性也仅限于其上下文，仅限**处于具有不安全、不可靠的通信环境的完全异步分布式系统中**才成立。

两位将军问题与网络连接都有着极为相似的安全隐患以及不可靠的通信通道，那么 **TCP(三次握手)** 又是如何建立起网络连接的呢？
事实上 TCP 也是不可靠的——在网络连接期间两个打开的端口只能每隔一段时间定时去发送数据包以确定对方的状态。
所以原则上 TCP 上的所有东西都是不可靠的，不管是 CDN 还是 P2P，任何分组交换网络都是不可靠的。

> 科学告诉你什么是可能以及不可能；而工程则告诉你，付出一些代价，不可能也可以变成可能——
  学术定理遵循的是严格的数学证明，考虑的是最极端的情况；而工程实践中，学术上的极端性一般情况下很少发生，即便发生，多试几次也就好了。
  譬如，每次都派出多名信使，将不可靠性消减到一个可以接受的程度；或者干脆成立一个中心化的通信枢纽，通信完全交给第三方进行协调。

### 拜占庭将军问题(Byzantine General's Problem)

["拜占庭将军问题"][byzantine generals problem]是由 Lamport、Shostak 和 Pease 于 1982 年提出的一个用于解释一致性问题的虚构模型。

> 拜占庭军队的几个师在一个敌人城市外扎营，每个师都有自己将军指挥，将军们只能通过信使互相沟通。
> <br />
> 在观察敌人后，将军们决定采用共同的计划行动。然而，一些将军可能是叛徒，试图阻止忠诚的将军达成共识。

这是两位将军问题的一个带反转的广义版本，它描绘了同样的场景，但增加了一层复杂性：其中一个或几个将军有可能是叛徒，叛徒可以选择说谎。

那么将军们想要达成共识必须有一个算法来保证：

1. 所有忠诚的将军都会采取同样的行动计划；
2. 在叛徒占少数的情况下，忠诚的将军将不会采取糟糕的计划。

无论叛徒做什么，算法都必须保证条件 **1** 满足。但条件 **2** 很难正式化，因为它需要准确地推测出错误的计划是什么。

#### 拜占庭容错(Byzantine Fault Tolerance)

拜占庭将军问题的解需要遵循一个定理：对于任意 `m`，如果有多于 `3m` 的将军和至多 `m` 个叛徒，那么算法 `OM(m)` 达到共识。

这意味着达成共识的算法将基于将军所观察到的其它大多数决策。如果将军们在有叛徒存在的情况下仍然达成了一致，我们就称达到了**拜占庭容错**。

拜占庭容错是一种系统的特征，它定义了该系统可以容忍 **拜占庭故障(Byzantine Failure)** 类别的故障模式。

> 拜占庭故障：属于拜占庭将军问题的一类故障，拜占庭故障是最为困难的一类故障模式。

拜占庭故障是最严重最难处理的故障之一。在飞机发动机系统、核电站和几乎所有行为取决于大量传感器结果的系统都需要拜占庭容错。

### 实用拜占庭容错(Practical Byzantine Fault Tolerance)

在分布式系统的环境中，BFT(拜占庭容错) 一直是分布式网络的重点研究对象，目前这项技术已经在大量的实践中拥有了不少的优秀的优化版本。

pBFT(实用拜占庭容错) 正是其中的众多优化之一，由 Castro 和 Liskov 于 1999 年发表的一篇题为
["Practical Byzantine Fault Tolerance"][pBFT] 的学术论文中被提出。
该算法旨在在异步系统中工作，经过优化，具有开销运行时的高性能，并且只有轻微的延迟增加。

pBFT 模型主要侧重于提供实用的拜占庭**状态机复制**。状态机通常被定义为下面这些值元组：

- **s**: 一组状态
- **i**: 一组输入
- **o**: 一组输出
- **f**: 一个转换函数(**input × s → s'**)
- **g**: 一个输出函数(**input × s → o**)
- **start**: 一个叫作"初始"的状态

一个拜占庭状态机从"初始"开始，每一个输入都被传入转换函数和输出函数，以生成一个新的状态和输出。
在新的输入被接收到前，状态保持不变，而输出同时被传输给恰当的接受者。

通过假设存在故障节点时以及**由特定独立的节点操纵信息的传播**来容忍拜占庭故障。
所有节点按顺序排序、彼此通信，不仅需要证明消息来自特定的对等节点，还需要验证消息在传输过程中是否未被修改，使所有诚实节点达成状态一致。

> pBFT 模型中的特定节点为主节点(leader)，其它节点称为备份节点。

<img src="/images/consensus/pBFT-str.jpg" width="50%">

为了使 pBFT 模型起到实际作用，故障的节点数量不能等于或超过系统中总节点数的 `⅓`。但只要不超过这个数量，该算法就能有效地提供安全性。

### 不足之处

如果将所有的状态机的副本组成的集合用 `R` 表示，允许失效的最大副本数量就是 `(|R| - 1) / 3` 个，姑且叫作 `F`：

![max nodes][pBFT-max]

再假设实际的故障节点有 `f` 个，那么为了得到共识所需的副本量只要 `3f + 1` 个：

![need nodes][pBFT-min]

由于实际上 `F = f` 的情况并不常见，大多数情况下也只有少数的故障节点，这时就多出来 `3(F - f)` 个无用的副本，姑且叫作 `p`：

![need nodes][pBFT-ex] 

多出额外的 `p` 个副本除了降低性能之外并不能提高可靠性。

<br />

---

<br />

## Paxos

Paxos 协议于 1989 年首次发布，并以希腊 Paxos 岛上使用的虚构立法共识系统命名，**是一系列用于在不可靠处理器网络中解决共识的协议**。

一系列的意思即字面意思，假设当前场景下能够满足 Paxos 的前置假设，那么：

1. 列举出一些场景，使得 Paxos 无法再满足一致性；
2. 接着再丰富 Paxos 的协议流程使得能够满足该场景；
3. 重复 **1** 和 **2**。

通过对协议流程不断地改进，使得在任意场景下 Paxos 都能够保证系统的一致性，最终就得到了完整的 Paxos 协议。

### 角色(Roles)

在共识的过程中，所有参与了共识的分布式节点都被分配了不同动作，Paxos 协议使用了不同的角色来描述这些不同的动作：

- **Client**：Client 唯一要做的就是向分布式系统发出请求，并等待响应。
- **Proposer(议员)**：议员用 Client 的请求发起**提案**，并在发生冲突时充当协调员推进协议。
- **Acceptor(选民)**：选民充当协议中的容错载体，选民被收集到一个名为**Quorums**的组中；
  所有发送给选民的消息都必须发送到选民的 Quorums 中；任何来自选民的消息都会被忽略，除非消息的副本都自选民的 Quorums。
- **Learner**：Learner 充当协议的复制因子，一旦一个 Client 的请求得到选民的**接受**，那么 Learner 就可以获得一个**动作**。
- **Leader**：

> 选民可以收到议员发起的提案，之后可以选择接受，若某个提案获得多数的接受，则称该提案被**批准**；Learner 只能获得被批准的提案。
>
> Learner 的动作包括执行请求或向客户发送响应等。

在经典的 Paxos 部署中，一个节点往往能够同时扮演一个或多个角色，并且在大多数时候都在同时扮演 Proposer、Acceptor、Learner 这三个角色。

### 不足之处

**传统 Paxos 协议需要满足一个前置假设：系统的环境是安全的，并不存在恶意的节点。**

Paxos 设计的初衷在于给大型企业服务器提供一种完全异步的分布式系统，虽然同样是为了解决分布式系统中的共识难题，
但 Paxos 最终解决的还是由于服务器的异步消息发送或者出现了网络故障、延迟等导致消息出现的先后各异或干脆丢失等问题。
也就是说系统不一定可靠，但却一定安全。

这就要求系统本身必须具有相当高的安全性，更正式的说就是要求**系统无拜占庭将军问题**。
这就导致了纵使 Paxos 能够极快地形成共识，但是却不适合作为大多数公链的共识算法来使用，而只能在一些私链上进行部署。

> Lamport 对此又提出了一种 Byzantine Paxos 的方案来解决这个问题。

**适用性低，实现的变数大。**

Paxos 拥有非常之多的变体，在不同的系统中往往需要满足不同的需求，无法统一的实现方案给移植带来了困难。
这导致了只有部分专业人士率领整个团队才能彻底满足系统的需求，提高了使用门槛。

<br />

---

<br />

## Raft

Raft 是一个用于实现分布式共识的协议，其共识过程可以简单地概括为：
**通过一种可靠的投票机制选举出一个 Leader 作为中央节点，所有对系统的改变都会在 Leader 的指挥下有序地完成。**
也就是说 Raft 可以算是一个中心化的共识算法。

当 Leader 出现问题无法继续胜任自己工作时，剩下的节点会非常迅速地投票选举出下一个 Leader。
这种做法有效地解决了传统架构的系统中某一台服务器发生系统故障时影响到剩余的服务器的问题，间接提高了系统整体的可靠性及高容错性。

### 领导选举(Leader Election)

Raft 的节点能够处于以下 3 种状态中的一种：

- Follower：
- Candidate：
- Leader：所有对系统的改变都在 Leader 的指挥下有序地完成。

所有节点都从一个 Follower 状态开始，如果一个 Follower 不接受 Leader 的意见那么它就可以成为候选人。 
成为 Candidate 的节点然后会请求其它节点对它投票，收到请求的节点就会回复它们的投票。
如果 Candidate 能够获得节点上的大多数投票那么它就会变成 Leader。

### 日志复制(Log Replication)

当客户端发送消息给服务器时，消息会最优先经过 Leader。但 Leader 不会马上对消息进行处理，而是将其作为一个 entry 添加到**节点日志**中。
**加入到节点日志的 entry 在未执行提交前不会对系统作出任何改变**。

> 节点日志可以类比成一个专门用于存放 TODO 操作的集合，每个 entry 相当于集合中的元素。

为了提交某条 entry，Leader 首先会将它复制到所有的 Follower 节点中，直到大多数节点都将这段 entry 添加到节点日志中。
如果大多数 Follower 都完成了操作并返回了回调，那么提交就算完成了。
接下来 Leader 会处理掉这项 entry 并更新系统的状态，并通知所有 Follower 更新自己的系统状态。

通过这种日志复制的操作，分布式集群能够就系统状态方面达成共识。

### 不足之处

通过随机的变数使随机的节点成为 Candidate 并选举为 Leader，之后的共识完全交给 Leader 完成，那么当出现恶意节点时，整个系统基本完蛋。
也就是说 Raft 同样要求**系统无拜占庭将军问题**。

<br />

---

<br />

## 总结

共识算法的选择与应用场景高度相关，可信环境使用 Paxos 或者 Raft，带许可的联盟链可使用 pBFT，非许可链可以是 PoW、PoS、ripple 等。
根据信任度分级，自由选择共识机制，此为最优。

{% assign img_url = "/images/consensus/" %}

[pBFT-max]: {{img_url}}/pBFT-max.gif
[pBFT-min]: {{img_url}}/pBFT-min.gif
[pBFT-ex]: {{img_url}}/pBFT-ex.gif

[bitcoin whitepaper]: https://bitcoin.org/en/bitcoin-paper
[cooperative theory]: https://en.wikipedia.org/wiki/Cooperative_game_theory
[byzantine generals problem]: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.9525&rep=rep1&type=pdf
[state machine replication]: https://en.wikipedia.org/wiki/State_machine_replication
[pBFT]: http://pmg.csail.mit.edu/papers/osdi99.pdf 
